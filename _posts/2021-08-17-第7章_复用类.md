# 第七章 复用类

## 组合语法

​	到目前为止，我们已经多次使用组合技术。**只需将对象引用置于新类中即可**。例如，假设你需要某个对象，它要具有多个 `String`对象、几个基本类型数据，以及另一个类的对象。对于非基本类型的对象，必须将其引用置于新的类中，但可以直接定义基本类型数据：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/10 17:14
 */
class WaterSource{
    private String s;
    WaterSource(){
        System.out.println("WaterSource()");
        s = "Constructed";
    }
    public String toString(){
        return s;
    }
}
public class SprinklerSystem {
    private String value;
    private WaterSource source = new WaterSource();
    private int i;
    private float f;

    @Override
    public String toString() {
        return "SprinklerSystem{" +
                "value='" + value + '\'' +
                ", source=" + source +
                ", i=" + i +
                ", f=" + f +
                '}';
    }
    public static void main(String[] args) {
        SprinklerSystem system = new SprinklerSystem();
        System.out.println(system);
    }
}
```



![image-20210810171831711](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210810171831711.png)

​	在上面两个类所定义的方法中，有一个很特殊的方法： `toString()`。毎一个非基本类型的对象都有一个  `toString()`方法，而且当编译器需要一个 `String`而你却只有一个对象时，该方法便会被调用。

​	编译器并不是简单地为毎一个引用都创建默认对象，这一点是很有意义的，因为若真要那样做的话，就会在许多情况下增加不必要的负担。如果想初始化这些引用，可以在代码中的下列位置进行：
1.在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。
2.在类的构造器中。
3.就在正要使用这些对象之前，这种方式称为**情性初始化**。在生成对象不值得及不必每次。
都生成对象的情况下，这种方式可以减少额外的负担。
4.使用实例初始化。

以下是这四种方式的示例：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/10 17:31
 */
class Soap{
    private String s;

    Soap(){
        System.out.println("Soap()");
        s = "Constructed";
    }

    @Override
    public String toString() {
        return s;
    }
}
public class Bath {
    private String s1 = "happy" , s2 = "newHappy",s3,s4;
    private Soap castille;
    private int i;
    private float toy;

    public Bath(){
        System.out.println("Inside Bath()");
        s3 = "Joy";
        toy = 3.14f;
        castille = new Soap();
    }
    { i = 47;}

    @Override
    public String toString() {
        if(null == s4){
            s4 = "Joy";
        }
        return "Bath{" +
                "s1='" + s1 + '\'' +
                ", s2='" + s2 + '\'' +
                ", s3='" + s3 + '\'' +
                ", s4='" + s4 + '\'' +
                ", castille=" + castille +
                ", i=" + i +
                ", toy=" + toy +
                '}';
    }

    public static void main(String[] args) {
        Bath b = new Bath();
        System.out.println(b);
    }
}

```

![image-20210810213441436](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210810213441436.png)

​	请注意，在`Bath`的构造器中，有一行语句在所有初始化产生之前就已经执行了。如果没有在定义处初始化，那么除非发生了不可避免的运行期异常，否则将不能保证信息在发送给对象引用之前已经被初始化。
​	当 `toString()`被调用时，它将填充`s4`的值，以确保所有的域在使用之时已被妥善初始化。
​	**练习1:(2)创建一个简单的类。在第二个类中，将一个引用定义为第一个类的对象。运用惰性初始化来实例化这个对象。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/10 21:39
 */
class Engine{
    private String s;
    Engine(){
        System.out.println("Engine()");
        s = "构造器";
    }

    @Override
    public String toString() {
        return "Engine{" +
                "s='" + s + '\'' +
                '}';
    }
}
public class Airplane {
    private String fuselage,wings,tail;
    private Engine e;
    public Airplane(){
        System.out.println("Inside Airplane()");
        fuselage = "Body";
        wings = "Airfoils";
        tail = "Empennage";
    }

    @Override
    public String toString() {
        if(null == e){  // 惰性初始化
            e = new Engine();
        }
        return "Airplane{" +
                "fuselage='" + fuselage + '\'' +
                ", wings='" + wings + '\'' +
                ", tail='" + tail + '\'' +
                ", e=" + e +
                '}';
    }

    public static void main(String[] args) {
        Airplane airplane = new Airplane();
        System.out.println(airplane);
    }
}


```

![image-20210810214609277](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210810214609277.png)

## 继承语法

​	继承是所有OOP语言和Java语言不可缺少的组成部分。当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是在隐式地从Java的标准根类 `Object`进行继承。

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/11 23:32
 */
class Cleanser{
    private String s = "Cleanser";
    public void append(String a){
        s += a;
    }
    public void dilute(){
        append("dilute()");
    }
    public void apply(){
        append("apply()");
    }
    public void scrub(){
        append("scrub()");
    }
    public String toString(){
        return s;
    }

    public static void main(String[] args) {
        Cleanser x = new Cleanser();
        x.dilute();
        x.apply();
        x.scrub();
        System.out.println(x);
    }
}
public class Detergent extends Cleanser{
    public void scrub(){
        append("Detergent.scrub()");
        super.scrub();
    }

    public void foam(){
        append("foam()");
    }

    public static void main(String[] args) {
        Detergent x = new Detergent();
        x.dilute();
        x.apply();
        x.scrub();
        x.foam();
        System.out.println(x);
        System.out.println("Testing base class:");
        Cleanser.main(args);
    }
}

```



![image-20210811234634672](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210811234634672.png)

​	 `Cleanser`和 `Detergent`均含有`main()`方法。可以为每个类都创建一个`main()`方法。这种在每个类中都设置一个`main()`方法的技术可使每个类的单元测试都变得简便易行。而且在完成单元测试之后，也无需删除`main()`,可以将其留待下次测试。

​	即使是一个程序中含有多个类，也只有命令行所调用的那个类的`main()`方法会被调用。因此，在此例中，如果命令行是 `java Detergent,`那么 `Detergent. main()`将会被调用。即使 `Cleanser`不是一个 `public`类，如果命令行是 `java Cleanser`,那么 `Cleanser. main()`仍然会被调用。即使个类只具有包访问权限，其 `public main()`仍然是可访问的。
​	在此例中，可以看到 `Detergent. main()`明确调用了 `Cleanser. main()`,并将从命令行获取的参数传递给了它。当然，也可以向其传递任意的 `String`数组。

​	正如我们在 `scrub`中所见，使用基类中定义的方法及对它进行修改是可行的。在此例中，你可能想要在新版本中调用从基类继承而来的方法。但是在 `scrub()`中，并不能直接调用 `scrub()`,因为这样做将会产生递归，而这并不是你所期望的。为解决此问题，<font color='red'>Java用 `super`关键字表示超类的意思</font>，当前类就是从超类继承来的。为此，表达式 `super. scrub()`将调用基类版本的 `scrub()`方法。

​	在继承的过程中，并不一定非得使用基类的方法。也可以在导出类中添加新方法，其添加方式与在类中添加任意方法一样，即对其加以定义即可。`foam()`方法即为一例。

​	**练习2:(2)从 Detergent中继承产生一个新的类。覆盖 scrub()并添加一个名为 sterilized的新方法。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/11 23:54
 */
public class Sterilizer extends Detergent {
    public void scrub(){
        append("Sterilizer.scrub()");
    }
    public void sterilize(){
        append("sterilize()");
    }
    public static void main(String[] args) {
        Sterilizer x = new Sterilizer();
        x.dilute();
        x.apply();
        x.scrub();
        x.foam();
        x.sterilize();
        System.out.println(x);
        System.out.println("Testing base class:");
        Detergent.main(args);
    }
}

```

![image-20210811235753814](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210811235753814.png)

### 初始化基类

​	对基类子对象的正确初始化也是至关重要的，而且也仅有一种方法来保证这一点：**在构造器中调用基类构造器来执行初始化**，而基类构造器具有执行基类初始化所需要的所有知识和能力。Java会自动在导出类的构造器中插入对基类构造器的调用。下例展示了上述机制在三层继承关系上是如何工作的：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/12 16:46
 */
class Art{
    Art(){
        System.out.println("Art constructor");
    }
}

class Drawing extends Art{
    Drawing(){
        System.out.println("Drawing constructor");
    }
}
public class Cartoon extends Drawing{
    public Cartoon(){
        System.out.println("Cartoon constructor");
    }
    public static void main(String[] args) {
        Cartoon cartoon = new Cartoon();

    }
}

```



![image-20210812164958964](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210812164958964.png)

​	我们会发现，构建过程是从基类“向外”扩散的，所以基类在导出类构造器可以访问它之前，就已经完成了初始化。**即使你不为 `Cartoon()`创建构造器，编译器也会为你合成一个默认的构造器，该构造器将调用基类的构造器。**

**练习3:(2)证明前面这句话。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/12 16:46
 */
class Art{
    Art(){
        System.out.println("Art constructor");
    }
}

class Drawing extends Art{
    Drawing(){
        System.out.println("Drawing constructor");
    }
}
public class Cartoon extends Drawing{
//    public Cartoon(){
//        System.out.println("Cartoon constructor");
//    }
    public static void main(String[] args) {
        Cartoon cartoon = new Cartoon();

    }
}

```

![image-20210812165412183](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210812165412183.png)

**练习4:(2)证明基类枃造器：(a)总是会被调用；(b)在导出类构造器之前被调用。**

``` java
import com.sun.crypto.provider.HmacMD5KeyGenerator;

/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/12 16:55
 */
class A{
    A(){
        System.out.println("A()");
    }
}
class B extends A{
    B(){
        System.out.println("B()");
    }
}

class C extends B{
    C(){
        System.out.println("C()");
    }
}

class D extends C{
    D(){
        System.out.println("D()");
    }
    public static D makeD(){
        return new D();
    }
    public static void main(String[] args) {
        D d = new D();
        D d2 = makeD();
    }
}
public class E extends D{
    E(){
        System.out.println("E()");
    }

    public static void main(String[] args) {
        E e = new E();
        D.main(args);
    }
}

```

``` 
A()
B()
C()
D()
E()
---------testD----------------
A()
B()
C()
D()
A()
B()
C()
D()
```



**练习5:(1)创建两个带有默认构造器（空参数列表）的类A和类B。从A中继承产生一个名为C的新类，并在C内创建一个B类的成员。不要给C编写构造器。创建一个C类的对象并观察其结果。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/12 17:12
 */
class A{
    A(){
        System.out.println("A()");
    }
}
class B extends A{
    B(){
        System.out.println("B()");
    }
}
public class C extends A {
    B b = new B(); // 2.然后会创建A和B构造器

    public static void main(String[] args) {
        C c = new C(); // 1.会先创建A构造器
    }
}

```

![image-20210812171542335](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210812171542335.png)

### 带参数的构造器

​	上例中各个类均含有默认的构造器，即这些构造器都不带参数。编译器可以轻松地调用它们是因为不必考虑要传递什么样的参数的问题。但是，如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，<font color='red'>就必须用关键字 `super`显式地编写调用基类构造器的语句</font >，并且配以适当的参数列表：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/12 17:23
 */
class Game{
    Game(int i){
        System.out.println("Game Construct");
    }
}
class BoardGame extends Game{
    BoardGame(int i){
        super(i);
        System.out.println("BoardGame Construct");
    }
}

public class Chess extends  BoardGame{
    Chess(){
        super(11);
        System.out.println("Chess Construct");
    }
    public static void main(String[] args) {
        Chess chess = new Chess();
    }
}

```

![image-20210812172634841](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210812172634841.png)

​	如果不在 `BoardGame()`中调用基类构造器，编译器将“抱怨”无法找到符合 `Game()`形式的构造器。而且，调用基类构造器必须是你在导出类构造器中要做的第一件事（如果你做错了编译器会提醒你）。

**练习6:(1)用 Chess java来证明前一段话。**

![image-20210812175849935](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210812175849935.png)

**练习7:(1)修改练习5,使A和B以带参数的构造器取代默认的构造器。为C写一个构造器，并在其中执行所有的初始化。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/12 17:12
 */
class A{
    A(char c,int i){
        System.out.println("A(char, int)");
    }
}
class B extends A{
    B(String s,float f){
        super(' ',0);
        System.out.println("B(String, float)");
    }
}
public class C extends A {
    private char c;
    private int i;
    C(char a,int j){
        super(a,j);
        c = a;
        i = j;
    }
    B b = new B("hi",1f);

    public static void main(String[] args) {
        C c = new C('b',2);
    }
}

```

![image-20210812180417840](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210812180417840.png)

**练习8:(1)创建一个基类，它仅有一个非默认构造器；再创建一个导出类，它带有默认构造器和非默认构造器。在导出类的构造器中调用基类的构造器。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 14:51
 */
class Aa{
    Aa(char c,int i){
        System.out.println("A(char,int)");
    }
}
public class Ex8 extends Aa {
    private char c;
    private int i;
    Ex8(){
        super('z',3);
    }
    Ex8(char a,int j){
        super(a,j);
        c = a;
        i = j;
        System.out.println("Ex8(char,int)");
    }

    public static void main(String[] args) {
        Ex8 ex1 = new Ex8();
        Ex8 ex2 = new Ex8('b',2);
    }
}

```

![image-20210814145624497](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814145624497.png)

**练习9:(2)创建一个Root类，令其含有名为 Component1、 Component2、 Component3的类的各一个实例（这些也由你写）。从Root中派生一个类Stem,也含有上述各“组成部分”。所有的类都应带有可打印出类的相关信息的默认构造器。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 14:57
 */
class Component1{
    Component1(){
        System.out.println("1");
    }
}

class Component2{
    Component2(){
        System.out.println("2");
    }
}

class Component3{
    Component3(){
        System.out.println("3");
    }
}

class Root{
    Component1 c1root;
    Component2 c2root;
    Component3 c3root;

    Root(){
        System.out.println("Root");
    }
}
public class Stem extends Root{
    Component1 c1Stem;
    Component2 c2Stem;
    Component3 c3Stem;
    Stem(){
        System.out.println("Stem");
    }
    public static void main(String[] args) {
        Stem s = new Stem();
    }
}

```

![image-20210814150029641](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814150029641.png)

**练习10:(1)修改练习9,使每个类都仅具有非默认的构造器。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 14:57
 */
class Component1{
    Component1(byte b){
        System.out.println("byte");
    }
}

class Component2{
    Component2(short s){
        System.out.println("short");
    }
}

class Component3{
    Component3(int i){
        System.out.println("int");
    }
}

class Root{
    Component1 c1root;
    Component2 c2root;
    Component3 c3root;

    Root(float f){
        c1root = new Component1((byte) 0);
        c2root = new Component2((short) 0);
        c3root = new Component3(0);
        System.out.println("Root float");
    }
}
public class Stem extends Root{
    Component1 c1Stem;
    Component2 c2Stem;
    Component3 c3Stem;
    Stem(double d){
        super(2.78f);
        c1Stem = new Component1((byte) 1);
        c2Stem = new Component2((short) 1);
        c3Stem = new Component3(1);
        System.out.println("Stem double");
    }
    public static void main(String[] args) {
        Stem s = new Stem(2.78);
    }
}

```

![image-20210814150458732](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814150458732.png)

## 代理

​	代理是结合了继承和组合的中庸之道，因为我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该成员对象的所有方法（就像继承）。例如，太空船需要一个控制模块：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 15:07
 */
public class SpaceShipControls {
    void  up(int velocity){}
    void  down(int velocity){}
    void  left(int velocity){}
    void  right(int velocity){}
    void  forward(int velocity){}
    void  back(int velocity){}
    void  turboBoost(int velocity){}
}
```

​	构造太空船的一种方式是使用继承：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 15:09
 */
public class SpaceShip extends SpaceShipControls{
    private String name;
    public SpaceShip(String name){
        this.name = name;
    }
    public String toString(){
        return name;
    }
    public static void main(String[] args) {
        SpaceShip ship = new SpaceShip("NSEA Protector");
        ship.forward(100);
    }
}
```

​	然而， `SpaceShip`并非真正的 `SpaceShipControls`类型，即便你可以“告诉” `SpaceShip`向前运动( `forward`)。更准确地讲， `SpaceShip`包含 `SpaceShipControls`,与此同时， `SpaceShipControlsa`的所有方法在 `SpaceShip`中都暴露了出来。代理解决了此难题：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 15:14
 */
public class SpaceShipDelegation {
    private String name;
    private SpaceShipControls controls = new SpaceShipControls();
    public SpaceShipDelegation(String name){
        this.name = name;
    }
    // Delegated methods:
    public void back(int v){
        controls.back(v);
    }
    public void down(int v){
        controls.down(v);
    }
    public void forward(int v){
        controls.forward(v);
    }
    public void left(int v){
        controls.left(v);
    }
    public void right(int v){
        controls.right(v);
    }
    public void up(int v){
        controls.up(v);
    }
    public void turboBoost(){
        controls.turboBoost();
    }

    public static void main(String[] args) {
        SpaceShipDelegation delegation = new SpaceShipDelegation("NSEA protector");
        delegation.forward(100);
    }
}

```

​	可以看到，上面的方法是如何转递给了底层的 `controls`对象，而其接口由此也就与使用继承得到的接口相同了。但是，**我们使用代理时可以拥有更多的控制力，因为我们可以选择只提供在成员对象中的方法的某个子集。**

​	**练习11:(3)修改 Detergent.java,让它使用代理**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/11 23:32
 */
class Cleanser{
    private String s = "Cleanser";
    public void append(String a){
        s += a;
    }
    public void dilute(){
        append("dilute() ");
    }
    public void apply(){
        append("apply() ");
    }
    public void scrub(){
        append("scrub() ");
    }
    public String toString(){
        return s;
    }

    public static void main(String[] args) {
        Cleanser x = new Cleanser();
        x.dilute();
        x.apply();
        x.scrub();
        System.out.println(x);
    }
}
public class Detergent{
    private String s = "Detergent";
    Cleanser cleanser = new Cleanser();
    public void append(String a){
        s+=a;
    }
    public void dilute(){
        cleanser.dilute();
    }
    public void apply(){
        cleanser.apply();
    }
    public void scrub(){
        append("Detergent.scrub()");
        cleanser.scrub();
    }
    public void foam(){
        append("foam()");
    }
    public String toString(){
        return s+" "+cleanser;
    }

    public static void main(String[] args) {
        Detergent detergent = new Detergent();
        detergent.dilute();
        detergent.apply();
        detergent.scrub();
        detergent.foam();
        System.out.println(detergent);
        System.out.println("Test base class: ");
        Cleanser.main(args);
    }



//    public void scrub(){
//        append("Detergent.scrub() ");
//        super.scrub();
//    }
//
//    public void foam(){
//        append("foam() ");
//    }
//
//    public static void main(String[] args) {
//        Detergent x = new Detergent();
//        x.dilute();
//        x.apply();
//        x.scrub();
//        x.foam();
//        System.out.println(x);
//        System.out.println("Testing base class:");
//        Cleanser.main(args);
//    }
}

```

![image-20210814153505389](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814153505389.png)

## 结合使用组合和继承

​	同时使用组合和继承是一件很常见的事，下面就是同时使用这两种技术的例子：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 15:37
 */
class  Plate{
    Plate(int i){
        System.out.println("Plate Constructed");
    }
}

class DinnerPlate extends Plate{
    DinnerPlate(int i){
        super(i);
        System.out.println("DinnerPlate Constructed");
    }
}

class  Utensil{
    Utensil(int i){
        System.out.println("Utensil Constructed");
    }
}
class Soopn extends  Utensil{
    Soopn(int i){
        super(i);
        System.out.println("Soopn Constructed");
    }
}
class Fork extends Utensil{
    Fork(int i){
        super(i);
        System.out.println("Fork Constructed");
    }
}
class Knife extends Utensil{
    Knife(int i){
        super(i);
        System.out.println("Knife Constructed");
    }
}
class Custom{
    Custom(int i){
        System.out.println("Custom Constructed");
    }
}
public class PlaceSetting extends Custom {
    private Soopn sp;
    private Fork fork;
    private Knife kf;
    private DinnerPlate pl;
    public PlaceSetting(int i){
        super(i+1);
        sp = new Soopn(i+2);
        fork = new Fork(i+3);
        kf = new Knife(i+4);
        pl = new DinnerPlate(i+5);
        System.out.println("PlaceSetting Constructed");
    }

    public static void main(String[] args) {
        PlaceSetting x = new PlaceSetting(9);
    }
}

```

![image-20210814161547410](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814161547410.png)

### 确保正确清理

​	Java中没有C++中析构函数的概念。析构函数是一种在对象被销毁时可以被自动调用的函数。其原因可能是因为在Java中，我们的习惯只是忘掉而不是销段对象，并且让垃圾回收器在必要时释放其内存。

​	请思考一下下面这个能在屏幕上绘制图案的计算机辅助设计系统示例：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 16:17
 */
class Shape{
    Shape(int i){
        System.out.println("Shape Constructor");
    }
    void dispose(){
        System.out.println("Shape dispose");
    }
}
class Circle extends Shape{
    Circle(int i){
        super(i);
        System.out.println("Drawing Circle");
    }
    void dispose(){
        System.out.println("Erasing Circle");
        super.dispose();
    }
}

class Triangle extends Shape{
    Triangle(int i){
        super(i);
        System.out.println("Drawing Triangle");
    }
    void dispose(){
        System.out.println("Erasing Triangle");
        super.dispose();
    }
}

class Line extends Shape{
    private int start,end;
    Line(int start,int end){
        super(start);
        this.start = start;
        this.end = end;
        System.out.println("Drawing Line:"+start+","+end);
    }
    void dispose(){
        System.out.println("Erasing Line:"+start+","+end);
        super.dispose();
    }
}
public class CADSystem extends Shape{
    private  Circle c;
    private Triangle t;
    private Line[] lines = new Line[3];
    CADSystem(int i){
        super(i+1);
        for (int j = 0; j < lines.length; j++) {
            lines[j] = new Line(j,j*j);
        }
        c = new Circle(1);
        t = new Triangle(1);
        System.out.println("CADSystem Constructor");
    }
    public void dispose(){
        System.out.println("CADSystem.dispose()");
        t.dispose();
        c.dispose();
        for (int i = 0; i < lines.length; i++) {
            lines[i].dispose();
        }
        super.dispose();
    }

    public static void main(String[] args) {
        CADSystem x = new CADSystem(47);
        try {
            // Code and exception handing...
        }finally {
            x.dispose();
        }
    }
}

```

``` 
Shape Constructor
Shape Constructor
Drawing Line:0,0
Shape Constructor
Drawing Line:1,1
Shape Constructor
Drawing Line:2,4
Shape Constructor
Drawing Circle
Shape Constructor
Drawing Triangle
CADSystem Constructor
CADSystem.dispose()
Erasing Triangle
Shape dispose
Erasing Circle
Shape dispose
Erasing Line:0,0
Shape dispose
Erasing Line:1,1
Shape dispose
Erasing Line:2,4
Shape dispose
Shape dispose
```

​	此系统中的一切都是某种 `Shape`( `Shape`自身就是一种 `Object`,因为 `Shape`继承自根类 `Object`)每个类都覆写 `Shape`的 `dispose`方法，并运用 `super`来调用该方法的基类版本。尽管对象生命期中任何被调用的方法都可以做一些必需的清理工作，但是 `Circle`、 `Triangle`和`Line`这些特定的`Shape`类仍然都带有可以进行“绘制”的构造器。**毎个类都有自己的 `dispose()`方法将未存于内存之中的东西恢复到对象存在之前的状态。**

​	在清理方法( `dispose`)中，还必须**注意对基类清理方法和成员对象清理方法的调用顺序以防某个子对象依赖于另一个子对象情形的发生**。一般而言，所采用的形式应该与C++编译器在其析构函数上所施加的形式相同：<font color='red'>首先，执行类的所有特定的清理动作，其顺序同生成顺序相反（通常这就要求基类元素仍旧存活）；然后，就如我们所示范的那样，调用基类的清理方法。</font>

**练习12:(3)将一个适当的 dispose0方法的层次结构添加到练习9的所有类中。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 14:57
 */
class Component1{
    Component1(byte b){
        System.out.println("byte");
    }
    void dispose() {
        System.out.println("Component1.dispose()") ;
    }
}

class Component2{
    Component2(short s){
        System.out.println("short");
    }
    void dispose() {
        System.out.println("Component2.dispose()") ;
    }
}

class Component3{
    Component3(int i){
        System.out.println("int");
    }
    void dispose() {
        System.out.println("Component3.dispose()") ;
    }
}

class Root{
    Component1 c1root;
    Component2 c2root;
    Component3 c3root;

    Root(float f){
        c1root = new Component1((byte) 0);
        c2root = new Component2((short) 0);
        c3root = new Component3(0);
        System.out.println("Root float");
    }
    void dispose(){
        c3root.dispose();
        c2root.dispose();
        c1root.dispose();
        System.out.println("Root  dispose()");
    }
}
public class Stem extends Root{
    Component1 c1Stem;
    Component2 c2Stem;
    Component3 c3Stem;
    Stem(double d){
        super(2.78f);
        c1Stem = new Component1((byte) 1);
        c2Stem = new Component2((short) 1);
        c3Stem = new Component3(1);
        System.out.println("Stem double");
    }
    void dispose(){
        c3Stem.dispose();
        c2Stem.dispose();
        c1Stem.dispose();
        super.dispose();
        System.out.println("Stem  dispose()");
    }
    public static void main(String[] args) {
        Stem s = new Stem(2.78);
        try {
            //  ...
        } finally {
            s.dispose();
        }
    }
}

```

``` 
byte
short
int
Root float
byte
short
int
Stem double
Component3.dispose()
Component2.dispose()
Component1.dispose()
Component3.dispose()
Component2.dispose()
Component1.dispose()
Root  dispose()
Stem  dispose()
```

### 名称屏蔽

​	如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本(这一点与C++不同)。因此，无论是在该层或者它的基类中对方法进行定义，重载机制都可以正常工作：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 16:45
 */
class Homer{
    char doh(char c){
        System.out.println("doh(char)");
        return 'd';
    }
    float doh(float f){
        System.out.println("doh(float)");
        return 1.0f;
    }
}
class Milhose{
}
class Bart extends Homer{
    void doh(Milhose m){
        System.out.println("doh(Milhose)");
    }
}
public class Hide {
    public static void main(String[] args) {
        Bart b = new Bart();
        b.doh(1);
        b.doh('x');
        b.doh(1.0f);
        b.doh(new Milhose());
    }
}

```

![image-20210814164844779](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814164844779.png)

​	可以看到，虽然`Bart`引入了一个新的重载方法（在C++中若要完成这项工作则需要屏蔽基类方法），**但是在`Bart`中 `Homer`的所有重载方法都是可用的**。使用与基类完全相同的特征签名及返回类型来覆盖具有相同名称的方法，是一件极其平常的事。但它也令人迷惑不解(这也就是为什么C++不允许这样做的原因所在——防止你可能会犯错误)。

**练习13:(2)创建一个类，它应带有一个被重载了三次的方法。继承产生一个新类，并添加一个该方法的新的重载定义，展示这四个方法在导出类中都是可以使用的**

```java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 16:51
 */
class ThreeWay{
    void number(byte b){
        System.out.println(b);
    }
    void number(short s){
        System.out.println(s);
    }
    void number(int i){
        System.out.println(i);
    }
}
public class Overload extends ThreeWay{
    void number(float f){
        System.out.println(f);
    }
    public static void main(String[] args) {
        Overload ov = new Overload();
        ov.number((byte) 0);
        ov.number((short) 1);
        ov.number(2);
        ov.number(3.0f);
    }
}
```

![image-20210814165410608](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814165410608.png)

## 在组合与继承之间选择

​	**组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地做**。读者或许想知道二者间的区别何在，以及怎样在二者之间做出选择

​	**组合**技术通常用于想在新类中**使用现有类的功能而非它的接口这种情形**。即，在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。为取得此效果，需要在新类中嵌入一个现有类的 `private`对象。
​	有时，允许类的用户直接访问新类中的组合成分是极具意义的，也就是说，将成员对象声明为 `public`。如果成员对象自身都隐藏了具体实现，那么这种做法是安全的。当用户能够了解到你正在组装一组部件时，会使得端口更加易于理解。`Car`对象即为一个很好的例子：

```java
import java.awt.*;

/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 16:57
 */
class Enginer{
    public void start(){}
    public void rev(){}
    public void stop(){}
}
class Wheel{
    public void inflate(int psi){}
        }
class Window{
    public void rollup(){}
    public void rolldown(){}
}
class Door{
    public Window window = new Window();
    public void open(){}
    public void close(){}
}
public class Car {
    public Enginer enginer = new Enginer();
    public Wheel[] wheels = new Wheel[4];
    public Door left = new Door();
    public Door right = new Door();
    public Car(){
        for (int i = 0; i < wheels.length; i++) {
            wheels[i] = new Wheel();
        }
    }

    public static void main(String[] args) {
        Car car = new Car();
        car.left.window.rollup();
        car.wheels[0].inflate(72);
    }
}
```

**练习14:(1)在 Car.java中给 Engine添加一个 service方法，并在main()中调用该方法。**

```java
import java.awt.*;

/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 16:57
 */
class Enginer{
    public void start(){}
    public void rev(){}
    public void stop(){}
    public void service(){
        System.out.println("service enginer");
    }
}
class Wheel{
    public void inflate(int psi){}
        }
class Window{
    public void rollup(){}
    public void rolldown(){}
}
class Door{
    public Window window = new Window();
    public void open(){}
    public void close(){}
}
public class Car {
    public Enginer enginer = new Enginer();
    public Wheel[] wheels = new Wheel[4];
    public Door left = new Door();
    public Door right = new Door();
    public Car(){
        for (int i = 0; i < wheels.length; i++) {
            wheels[i] = new Wheel();
        }
    }

    public static void main(String[] args) {
        Car car = new Car();
        car.left.window.rollup();
        car.wheels[0].inflate(72);
        car.enginer.service();
    }
}
```

![image-20210814170729259](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814170729259.png)

## protected关键字

​	在实际项目中，我们经常会想要将某些事物尽可能对这个世界隐藏起来，但仍然允许导出类的成员访问它们。
​	关键字 `protected`就是起这个作用的。**它指明“就类用户而言，这是 `private`的，但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的。"（ protected地提供了包内访问权限。）**
​	尽管可以创建 `protected`域，但是最好的方式还是将域保持为 `private`;你应当一直保留“更改底层实现”的权利。然后通过 `protected`方法来控制类的继承者的访问权限。

``` java

/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 17:10
 */
class Villain{
    private String name;
    protected void set(String nm){
        name = nm;
    }
    public Villain(String name){
        this.name = name;
    }

    @Override
    public String toString() {
        return "Villain{" +
                "name='" + name + '\'' +
                '}';
    }
}
public class Orc extends Villain{
    private int orcNumber;
    public Orc(String name,int orcNumber){
        super(name);
        this.orcNumber = orcNumber;
    }
    public void change(String name,int orcNumber){
        set(name);
        this.orcNumber = orcNumber;
    }

    @Override
    public String toString() {
        return "Orc{" + "orcNumber= " + orcNumber + '}'+" "+super.toString();
    }

    public static void main(String[] args) {
        Orc orc = new Orc("Limburger",12);
        System.out.println(orc);
        orc.change("Bob",19);
        System.out.println(orc);
    }
}

```

![image-20210814171554588](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814171554588.png)

可以发现， `change()`可以访问`set()`,这是因为它是 `protected`的。还应注意`Orc`的 `toString()`方法的定义方式，它依据 `toString`的基类版本而定义;

  **练习15:(2)在包中编写一个类，类应具备一个 protected方法。在包外部，试着调用该protected方法并解释其结果。然后，从你的类中继承产生一个类，并从该导出类的方法内部调用该protected方法。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 17:21
 
 public class BasicDevice {
    private String s = "Original";
    public BasicDevice(){
        s = "Original";
    }
    protected void changeS(String c){
        s = c;
    }
    public void showS(){
        System.out.println(s);
    }
}
 */
class DeviceFail{
    public static void main(String[] args) {
        BasicDevice fail = new BasicDevice();
        fail.showS();
//        fail.changeS("say-goodbye");// cannot access protected method 	
    }
}
public class Device extends BasicDevice {
    void changeBasic(String t){
        super.changeS(t);
    }

    public static void main(String[] args) {
        Device d  = new Device();
        d.showS();
        d.changeBasic("Changed");
        d.showS();
        DeviceFail.main(args);
    }
}

```

![image-20210814172622853](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814172622853.png)

## 向上转型

“为新的类提供方法”并不是继承技术中最重要的方面，其**最重要的方面是用来表现新类和基类之间的关系**。这种关系可以用“新类是现有类的一种类型”这句话加以概括。

​	这个描述并非只是一种解释继承的华丽的方式，这直接是由语言所支撑的。例如，假设有一个称为 `Instrument`的代表乐器的基类和一个称为`Wind`的导出类。由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。如果 `Instrument`类具有一个`play()`方法，那么`Wind`乐器也将同样具备。这意味着我们可以准确地说`Wind`对象也是一种类型的 `Instrument`。下面这个例子说明了编译器是怎样支持这一概念的:

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 17:37
 */
class Instrument{
    public void play(){}
    static void tune(Instrument i){
        i.play();
    }
}
public class Wind extends Instrument{
    public static void main(String[] args) {
        Wind flute = new Wind();
        Instrument.tune(flute);// 向上转型
    }
}

```

在上面的示例代码中，`tune()`方法可以接受`Instrument`引用，我们称之为**向上转型**。

​	**练习16:(2)创建一个名为 Amphibian的类。由此继承产生一个称为Frog的类。在基类中设置适当的方法。在main()中，创建一个Frog并向上转型至 Amphibian,然后说明所有方法都可工作。**

``` java
**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 17:43
 */
class Amphibian{
    protected void swim(){
        System.out.println("Amphibian swim");
    }
    protected void speak(){
        System.out.println("Amphibian speak");
    }
    void eat(){
        System.out.println("Amphibian eat");
    }
    static void grow(Amphibian  a){
        System.out.println("Amphibian grow");
        a.eat();
    }
}
public class Frog  extends Amphibian{
    public static void main(String[] args) {
        Frog f = new Frog();
        f.swim();
        f.eat();
        f.speak();
        Amphibian.grow(f);
    }
}
```

![image-20210814174614759](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814174614759.png)

​	**练习17:(1)修改练习16,使Frog覆盖基类中方法的定义（令新定义使用相同的方法特征签名）。请留心main()中都发生了什么。**

```java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/14 17:43
 */
class Amphibian{
    protected void swim(){
        System.out.println("Amphibian swim");
    }
    protected void speak(){
        System.out.println("Amphibian speak");
    }
    void eat(){
        System.out.println("Amphibian eat");
    }
    static void grow(Amphibian  a){
        System.out.println("Amphibian grow");
        a.eat();
    }
}
public class Frog  extends Amphibian{
    @Override
    protected void swim(){
        System.out.println("Frog swim");
    }
    @Override
    protected void speak(){
        System.out.println("Frog speak");
    }
    @Override
    protected void eat(){
        System.out.println("Frog eat");
    }
    static void grow(Amphibian a){
        System.out.println("Frog grow");
        a.eat();
    }
    public static void main(String[] args) {
        Frog f = new Frog();
        f.swim();
        f.eat();
        f.speak();
        f.grow(f);// upcast Frog to Amphibian argument:
        Amphibian.grow(f);// upcast Frog to Amphibian and call Amphibian method:
    }
}
```

![image-20210814175022593](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210814175022593.png)

## final关键字

### final数据

​	许多编程语言都有某种方法，来向编译器告知一块数据是恒定不变的。有时数据的恒定不变是很有用的，比如：

```
1. 一个永不改变的编译时常量。
2.一个在运行时被初始化的值，而你不希望它被改变。
```

​	对于编译期常量这种情况，编译器可以将该常量值代入任何可能用到它的计算式中，也就是说，可以在编译时执行计算式，这减轻了一些运行时的负担。在Java中，这类常量必须是基本数据类型，并且以关键字`final`表示。在对这个常量进行定义的时候，必须对其进行赋值。
​	**一个既是 `static`又是`final`的域只占据一段不能改变的存储空间。**

当对象对象的引用使用final修饰符时，会使得其引用恒定不变，一旦引用被初始化指向一个对象，就再也无法把它指向另一个对象。

​	**练习18:(2)创建一个含有 static final域和fnal域的类，说明二者间的区别。**

```java
import java.util.Random;

/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/15 13:53
 */
class Test{
    Test(){
        System.out.println("Test()");
    }
}
public class Difference {
    private String name;
    public Difference(String s){
        name = s;
    }
    static final Test sft = new Test(); // constant reference address
    private final Test ft = new Test();
    static final String SFS = "static final";
    private final String fs = "final";
    private static Random random = new Random();
    static final int SFI = random.nextInt(); // class constant
    private final int fi = random.nextInt();

    @Override
    public String toString() {
        return "Difference{" +
                "name='" + name + '\'' +
                ", ft=" + ft +
                ", fs='" + fs + '\'' +
                ", fi=" + fi +
                '}';
    }

    public static void main(String[] args) {
        Difference d1 = new Difference("d1");
        Difference d2 = new Difference("d2");
        Difference d3 = new Difference("d3");
        System.out.println(d1);
        System.out.println(d2);
        System.out.println(d3);
    }
}
```

​	简单来看，`static final` 跟 `final` 的区别就是前者多了个`static`。`static`表示是静态的，它含有两个很关键的特点：

​	一、static`分配的存储空间不会变，而且`static`会在装载的时候初始化，而不是每次创建新对象时都初始化。

​	二、`static`修饰的属性或方法又叫类属性或类方法，也就说可以直接通过类名进行调用。

![image-20210815140828794](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210815140828794.png)

​	说明：`sft`是`static`的，所以只被初始化一次，而`ft`被初始化了三次。`SFI`的值是不会在第二次创建对象时发生改变的，因为它是`static`的，在装载时已被初始化，而不是每次创建新对象时都初始化。直接使用类名来调用类属性或类方法没有在这演示。

### 空白final

​	Java充许生成“空白`final`”，**所谓空白`final`是指被声明为`final`但又未给定初值的域**。无论什么情况，编译器都确保空白 `final`在使用前必须被初始化。但是，空白`final`在关键字`final`的使用上提供了更大的灵活性，为此，一个类中的`final`域就可以做到根据对象而有所不同，却又保持其恒定不变的特性。下面即为一例：

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/15 14:11
 */
class Poppet{
    private int i;
    Poppet(int ii){
        i = ii;
    }
}
public class BlankFinal {
    private final int i=0; // 初始化的final
    private final int j; // 空白final
    private final Poppet p; // 空白引用final

    /**
     * 空白final必须得在构造器中进行初始化
     */
    public BlankFinal(){
        j = 1; // 初始化空白final
        p = new Poppet(1); // 初始化空白引用final
    }
    public BlankFinal(int x){
        j = x;
        p = new Poppet(x);
    }
    public static void main(String[] args) {
        new BlankFinal();
        new BlankFinal(47);
    }
}

```

​	**必须在域的定义处或者每个构造器中用表达式对`final`进行赋值，这正是`final`域在使用前总是被初始化的原因所在。**

### final方法

​	使用`final`方法的原因有两个。**第一个原因是把方法锁定，以防任何继承类修改它的含义**。这是出于设计的考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。

​	过去建议使用`final`方法的第二个原因是效率。在Java的早期实现中，如果将一个方法指明为就是同意编译器将针对该方法的所有调用都转为内嵌调用。当编译器发现一个 `final`方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常方式而执行方法调用机制(将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值)，并且以方法体中的实际代码的副本来替代方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码就会膨胀，因而可能看不到内嵌带来的任何性能提高，因为，所带来的性能提高会因为花费于方法内的时间量而被缩减。

### final和private关键字

​	**类中所有的 `private`方法都隐式地指定为是final的**。由于无法取用 `private`方法，所以也就无法覆盖它。可以对 `private`方法添加`final`修饰词，但这并不能给该方法增加任何额外的意义。

**练习21:(1)创建一个带final方法的类。由此继承产生一个类并尝试覆盖该方法。**

``` java 
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/15 14:25
 */
class WithFinal{
    final void f(){
        System.out.println("输出WithFinal.f()");
    }
    void g(){
        System.out.println("输出WithFinal.g()");
    }
    final void h(){
        System.out.println("输出WithFinal.h()");
    }
}
class OverrideFinal extends WithFinal{
    /**
     * 尝试进行重写
     */
//    public final  void f(){} // 臣妾办不到
    @Override
    public void g(){} // OK, fine;

//    final void h(){} // 臣妾办不到
}
public class FinalOverrideEx {
    public static void main(String[] args) {
        OverrideFinal of = new OverrideFinal();
        of.f();
        of.g();
        of.h();
        WithFinal wf = of;
        wf.f();
        wf.g();
        wf.h();
    }
}

```

![image-20210815143032961](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210815143032961.png)

### final类

​	当将某个类的整体定义为`final`时(通过将关键字`final`置于它的定义之前)，就表明了你不打算继承该类，而且也不允许别人这样做。换句话说，出于某种考虑，你对该类的设计永不需做任何变动，或者出于安全的考虑，你不希望它有子类。

**练习22:(1)创建一个final类并试着继承它。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/15 14:38
 */
class SmallBrain{
}
final class Dinosaur{
    SmallBrain x = new SmallBrain();
}
//class Further  extends Dinosaur{ } // 臣妾办不到~
public class JurassicEx {
    public static void main(String[] args) {
        Dinosaur dinosaur = new Dinosaur();
    }
}

```

![image-20210815144008131](https://gitee.com/picktang/cloudimages/raw/master/img/image-20210815144008131.png)

## 初始化以及类的加载

在许多传统语言中，程序是作为启动过程的一部分立刻被加载的。然后是初始化，紧接着程序开始运行。这些语言的初始化过程必须小心控制，以确保定义为 `static`的东西，其初始化顺序不会造成麻烦。例如C++中，如果某个 `static`期望另ー个 `static`在被初始化之前就能有效地使用它，那么就会出现问题。

​	Java就不会出现这个问题，因为它采用了一种不同的加载方式。加载是众多变得更加容易的动作之一，因为Java中的所有事物都是对象。请记住，**每个类的编译代码都存在于它自己的独立的文件中**。**该文件只在需要使用程序代码时才会被加载**。一般来说，可以说：“类的代码在初次使用时才加载。”这通常是指加载发生于创建类的第一个对象之时，但是当访向 `static`域或`static`方法时，也会发生加载°。初次使用之处也是 `static`初始化发生之处。所有的 `static`对象和 `static`代码段都会在加载时依程序中的顺序(即，定义类时的书写顺序)而依次初始化。当然，定义为 `static`的东西只会被初始化一次。

**练习23:(2)请证明加载类的动作仅发生一次。证明该类的第一个实体的创建或者对 static成员的访问都有可能引起加载。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/15 14:46
 */
class AA{
    static int j = printInit("AA.j 被初始化了");
    static int printInit(String s){
        System.out.println(s);
        return 1;
    }
    AA(){
        System.out.println("AA()的构造器");
    }
}
class BB extends AA{
    static int k = printInit("BB.k被初始化了");
    BB(){
        System.out.println("BB()的构造器");
    }
}
class CC{
    static int n = printInitCC("CC.n被初始化了");
    static AA aa = new AA();
    CC(){
        System.out.println("CC()的构造器");
    }
    static int printInitCC(String s){
        System.out.println(s);
        return 1;
    }
}
class DD{
    DD(){
        System.out.println("DD()的构造器");
    }
}
public class LoadClass extends BB{
    static int i = printInit("LoadClass.i被初始化了");
    LoadClass(){
        System.out.println("LoadClass()构造器");
    }
    public static void main(String[] args) {
        LoadClass loadClass = new LoadClass(); // 调用LoadClass构造器
        System.out.println("--------------------------");
        System.out.println(CC.aa);
        System.out.println("--------------------------");
        DD dd =  new DD();
    }
}

```

``` 
AA.j 被初始化了
BB.k被初始化了
LoadClass.i被初始化了
AA()的构造器
BB()的构造器
LoadClass()构造器
--------------------------
CC.n被初始化了
AA()的构造器
AA@1540e19d
--------------------------
DD()的构造器
```



**练习24:(2)在 Beetle. java中，从 Beetle类继承产生一个具体类型的“甲壳虫”。其形式与现有类相同，跟踪并解释其输出结果。**

``` java
/**
 * @author Tangwenbo
 * @version JDK 1.8
 * @date 2021/8/15 15:02
 */
class Insect{
    private int i= 9;
    protected int j;
    Insect(){
        System.out.println("i = "+i+" ," + " j = "+j);
        j = 39;
    }
    private static int x = printInit("static Insect.x 被初始化了");
    static int printInit(String x){
        System.out.println(x);
        return 47;
    }
}
class Beetle extends Insect{
    private int k = printInit("Beetle.k 被初始化了 ");
    public Beetle(){
        System.out.println("k = "+k);
        System.out.println("j = "+j);
    }
    private static int x = printInit("static Beetle.x 被初始化了");
}
public class Scarab extends Beetle{
    private int n = printInit("Scarab.n被初始化了");
    public Scarab(){
        System.out.println("n = "+n);
        System.out.println("j = "+j);
    }
    private static int x = printInit(" Scarab.x 被初始化了");
    public static void main(String[] args) {
        Scarab scarab = new Scarab();
    }
}

```

``` 
static Insect.x 被初始化了
static Beetle.x 被初始化了
Scarab.x 被初始化了
i = 9 , j = 0
Beetle.k 被初始化了 
k = 47
j = 39
Scarab.n被初始化了
n = 47
j = 39
```




​    





